if (data_container()) {
    cout << "\t\t\tDATA :\n" << "\t\t\t";
    data.top().show_data();
    cout << "\t\t\tSONG\'S NAME : "; cout << data.top().get_songs_name() << endl;
  }


template<typename DATA_TYPE, size_t N, size_t M, size_t ff>
shared_ptr<typename RPlus<DATA_TYPE, N, M, ff>::Node> RPlus<DATA_TYPE, N, M, ff>::pack(ENTRY_GROUP &S) {
  if (S.size() <= ff) {
    shared_ptr<Node> newnode = make_shared<Node>();
    newnode->add(S);
    return newnode;
  }

  ENTRY_GROUP set_after_partition = partition(S);
  shared_ptr<Node> newnode = make_shared<Node>();
  newnode->add(set_after_partition);
  return newnode;
}

/*
template<typename DATA_TYPE, size_t N, size_t M, size_t ff>
shared_ptr<typename RPlus<DATA_TYPE, N, M, ff>::Node> RPlus<DATA_TYPE, N, M, ff>::pack(ENTRY_GROUP &S) {
  if (S.size() <= ff) {
    shared_ptr<Node> newnode = make_shared<Node>();
    newnode->add(S);
    return newnode;
  }
  ENTRY_GROUP S_next_level;
  while (!S.empty()) {
    pair<shared_ptr<Node>, ENTRY_GROUP> set_after_partition = partition(S);
    Entry entry_for_next_level(set_after_partition.first);
    S_next_level.push_back(entry_for_next_level);
    S.swap(set_after_partition.second);//S = remainder hyperectangles
  }
  return pack(S_next_level);
}*/

/*
pair<ENTRY_GROUP,ENTRY_GROUP> partition(ENTRY_GROUP &S) {
  if |S| <= ff {
    ENTRY_GROUP EmptyG
    return make_pair(S,EmptyG)
  }
  optimal_dim = 0
  cheapest_cost = 0
  optimal_cutline = 0.0;
  for each dim in dims {
    cost_and_cutline = sweep(dim, S)
    cheapest_cost = min(cost_and_cutline.cost, cheapest_cost)
    if cheapest_cost changed {
      optimal_cutline = cost_and_cutline.cutline
      optimal_dim = dim
    }
  }
  S1, S2
  for each entry in S {
    if entry.mbr.minbound[optimal_dim] < optimal_cutline {
      S1.push_back(entry)
    }
    else {
      S2.push_back(entry)
    }
  }
  return make_pair(S1,S2)
}
*/

/*
template<typename DATA_TYPE, size_t N, size_t M, size_t ff>
pair<shared_ptr<typename RPlus<DATA_TYPE, N, M, ff>::Node>, vector<typename RPlus<DATA_TYPE, N, M, ff>::Entry>>
                                        RPlus<DATA_TYPE, N, M, ff>::partition(ENTRY_GROUP &S) {
  if (S.size() <= ff) {
    shared_ptr<Node> newnode = make_shared<Node>();
    newnode->add(S);
    ENTRY_GROUP empty_group;
    return make_pair(newnode, empty_group);
  }
  //compute lowest coords #not necessary

  COST cheapest_cost = DBL_MAX;
  size_t cheapest_dim = current_dim;
  double optimal_cutline = 0.0;

  for (size_t current_dim = size_t(0); current_dim < N; ++current_dim) {
    //compute cost with sweep
    pair<COST, double> cost_and_cutline = sweep(current_dim, S);
    COST temp_cost = cheapest_cost;
    cheapest_cost = min(cheapest_cost, cost_and_cutline.first);
    if (cheapest_cost != temp_cost) {
      cheapest_dim = current_dim;
      optimal_cutline = cost_and_cutline.second;
    }
  }
  ENTRY_GROUP selected_entries, remainder_entries;
  shared_ptr<Node> R = make_shared<Node>();
  for (Entry &entry : S) {
    if (entry.get_mbr().get_boundaries().first[cheapest_dim] < optimal_cutline) {
      selected_entries.push_back(entry);
    }
    else {
      remainder_entries.push_back(entry);
    }
  }
  R->add(selected_entries);
  return make_pair(R, remainder_entries);
}*/

double MINMAXDIST(HyperPoint<T> p, const HyperRectangle<N> r);//not necessary but could be if overlap would exist

//DIST TO FURTHEST CORNER - NEAREST SIDE OF HYPERETANGLE
template<typename T, size_t N, size_t M, size_t ff>
double RPlus<T, N, M, ff>::MINMAXDIST(T p, const HyperRectangle<N> r) {
  double minmax = DBL_MAX;
  for (size_t i = size_t(0); i < N; ++i) {
    double RMsum = 0.0;
    for (size_t j = size_t(0); j < N; ++j) {
      if (j != i) {
        if (p[j] >= (r.get_boundaries().first[j] + r.get_boundaries().second[j]) / 2)
          RMsum += pow(p[j] - r.get_boundaries().first[j], 2);
        else
          RMsum += pow(p[j] - r.get_boundaries().second[j], 2);
      }
    }
    if (p[i] <= (r.get_boundaries().first[i] + r.get_boundaries().second[i]) / 2)
      minmax = min(pow(p[i] - r.get_boundaries().first[i], 2) + RMsum, minmax);
    else
      minmax = min(pow(p[i] - r.get_boundaries().second[i], 2) + RMsum, minmax);
  }
  return sqrt(minmax);
}

/*
  ALERT("__split_init__");
  tuple<ENTRY_GROUP, ENTRY_GROUP, ENTRY_GROUP> partitioned_group = partition(&A->entries);
  A = make_shared<Node>();
  A->add(get<0>(partitioned_group));
  shared_ptr<Node> B = make_shared<Node>();
  B->add(get<1>(partitioned_group));
  for (Entry &entry : get<2>(partitioned_group)) {
    if (A->is_leaf()) {
      A->add(entry);
      B->add(entry);
    }
    else {
      //split_node(entry.child);
      //add the two newnodes to entry.child
    }
  }
  ALERT("__repeated_entries__");
  if (R == root) {
    shared_ptr<Node> new_root = make_shared<Node>();
    Entry en1(R), en2(N2);
    new_root->add(en1); new_root->add(en2);
    root = new_root;
  }
  else {
    shared_ptr<Node> PR = R->parent;
    Entry right_node_after_split(N2);
    PR->add(right_node_after_split);
    if (PR->get_size() > M) {
      split_node(PR);
    }
  }
  ALERT("__split_done__");*/

///////////tests/////////////////////
{
    HyperPoint<double, 5> point(array<double, 5>{12, 1987, 15, 26, 12548.0256});
    point.show_data();
  }
  {
    HyperPoint<int, 2> point;
    point.show_data();
  }
  {
    HyperPoint<int, 2> A(array<int, 2>{80, 10});
    HyperPoint<int, 2> B(array<int, 2>{50, 20});
    HyperRectangle<int, 2> rect(A, B);
    rect.show_data();
  }
  {
    HyperPoint<int, 2> A(array<int, 2>{30, 10});
    HyperPoint<int, 2> B(array<int, 2>{50, 20});
    HyperRectangle<int, 2> rect(A, B, true);
    rect.show_data();
    HyperPoint<int, 2> C(array<int, 2>{90, 2});
    rect.insert_data(&C);
    rect.show_data();

    HyperPoint<int, 2> D(array<int, 2>{80, 70});
    HyperPoint<int, 2> E(array<int, 2>{120, 130});
    HyperRectangle<int, 2> rect2(D, E, true);
    rect2.show_data();

    rect.adjust(rect2);
    rect.show_data();
  }
  {
    HyperPoint<int, 2> A(array<int, 2>{20, 20});
    HyperPoint<int, 2> B(array<int, 2>{30, 30});
    HyperRectangle<int, 2> rect(A, B);
    rect.show_data();

    HyperPoint<int, 2> D(array<int, 2>{30, 29});
    HyperPoint<int, 2> E(array<int, 2>{40, 50});
    HyperRectangle<int, 2> rect2(D, E);
    rect2.show_data();

    cout << rect.overlaps(rect2) << endl;
    cout << rect2.overlaps(rect) << endl;
  }
  {
    HyperPoint<int, 2> A(array<int, 2>{210, 20});
    HyperPoint<int, 2> B(array<int, 2>{30, 130});
    HyperRectangle<int, 2> rect(A, B);
    rect.show_data();
    cout << rect.get_hypervolume() << endl;
  }
  {
    HyperPoint<int, 2> A(array<int, 2>{10, 25});
    HyperPoint<int, 2> B(array<int, 2>{80, 100});
    HyperRectangle<int, 2> rect(A, B);
    rect.get_boundaries().first.show_data();
    rect.get_boundaries().second.show_data();
  }